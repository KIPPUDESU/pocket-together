# 头像裁剪功能

本文以数据类型 `Blob` 的生命周期简单描述 `UpdateAvatar.vue` 组件中头像裁剪功能的实现

`Blob` 是图片的原始数据

## 依赖
**`vue-advanced-cropper`**: 核心的第三方 Vue 组件，提供图片裁剪框
---

## 原始 Blob

先是在裁剪框显示用户上传的原始图片（originalImage）
用户在裁剪框中调整选区并确定后，`crop` 函数触发，第一个 `Blob` 出现

1.  **获取 Canvas**:
    ```javascript
    const result = cropperRef.value.getResult();
    const canvas = result.canvas;
    ```
    - 从 advanced-cropper 获取裁剪结果，`<canvas>`元素上面绘制了用户选中的图像区域

2.  **Canvas 转为 Blob**
    ```javascript
    result.canvas?.toBlob(async (blob) => {
      // ...？？？...
    });
    ```
    - 调用`canvas.toBlob()`将 Canvas 的像素异步转换为 `Blob` 对象
---

## 最终 Blob

1.  **`Blob` => `HTMLImageElement`**:
    ```javascript
    const imageEl = await imageLoadImageFromBlobService(blob);
    ```
    - 调用在`image.ts`函数11里定义的`imageLoadImageFromBlobService`，将原始 `Blob` 加载成 HTMLImageElement

2.  **规范化**:
    ```javascript
    const imageResize = imageResizeImageService(
      imageEl,
      fileUserAvatarConfig.imageResizeNumber,
      fileUserAvatarConfig.imageResizeNumber
    )
    ```
    - 调用`imageResizeImageService`函数，将上一步得到的 `imageEl` 绘制到一个新的、具有预设尺寸（例如 200x200）的 `<canvas>` 上

3.  **重编码**:
    ```javascript
    const imageBlob = await new Promise<Blob>((resolve) => {
      imageResize.toBlob(
        (blob) => { resolve(blob); },
        fileUserAvatarConfig.toBlobType,
        fileUserAvatarConfig.toBlobQuality
      );
    });
    ```
    - 再调用 `canvas.toBlob()`，但这次是在缩放后的新 `canvas` 上操作
    - 这个新的 `imageBlob` 是经过 **裁剪、缩放、压缩** 后的
---

## 分开 Blob

最后的的 `imageBlob` 诞生后，要做两件事

- **前端预览**
    ```javascript
    imageUrlRef.value = URL.createObjectURL(imageBlob)
    ```

- **数据存储**
    ```javascript
    imageBlobRef.value = imageBlob
    ```

---

## 上传至服务器

当用户点击“保存”按钮，`Blob` 的旅程迎来了最终章。

- 封装后进行发送

---

## 总结

总之，该功能通过一系列定义明确的步骤，实现了对用户上传头像的完整处理流程  
重点是数据`Blob`从用户输入裁剪到标准化，再到最终应用的路径  

### 2025.08.07 切符 共勉